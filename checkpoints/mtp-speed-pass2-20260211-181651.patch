diff --git a/external/libhaze/include/haze.h b/external/libhaze/include/haze.h
index 102b7a3..5044a4aa 100644
--- a/external/libhaze/include/haze.h
+++ b/external/libhaze/include/haze.h
@@ -52,6 +52,9 @@ typedef void(*Callback)(const CallbackData* data);
 struct FileSystemProxyImpl {
     virtual const char* GetName() const = 0;
     virtual const char* GetDisplayName() const = 0;
+    /* PTP/MTP access capability:
+     * 0 = ReadWrite, 1 = ReadOnly, 2 = ReadOnlyWithObjectDeletion. */
+    virtual u16 GetAccessCapability() const { return 0; }
 
     virtual Result GetTotalSpace(const char *path, s64 *out) = 0;
     virtual Result GetFreeSpace(const char *path, s64 *out) = 0;
diff --git a/external/libhaze/include/haze/ptp_responder.hpp b/external/libhaze/include/haze/ptp_responder.hpp
index a914486..67f21c0 100644
--- a/external/libhaze/include/haze/ptp_responder.hpp
+++ b/external/libhaze/include/haze/ptp_responder.hpp
@@ -22,6 +22,8 @@
 #include <haze/ptp_object_database.hpp>
 #include <haze/ptp_responder_types.hpp>
 #include <optional>
+#include <string>
+#include <unordered_map>
 
 namespace haze {
 
@@ -47,10 +49,11 @@ namespace haze {
             u32 m_send_object_id;
             std::optional<ObjectPropList> m_send_prop_list;
             bool m_session_open;
+            std::unordered_map<std::string, u64> m_cached_object_sizes;
 
             PtpObjectDatabase m_object_database;
         public:
-            constexpr explicit PtpResponder(Callback callback = nullptr) : m_callback{callback}, m_usb_server(), m_fs_entries(), m_request_header(), m_object_heap(), m_buffers(), m_send_object_id(), m_session_open(), m_object_database() { /* ... */ }
+            explicit PtpResponder(Callback callback = nullptr) : m_callback{callback}, m_usb_server(), m_fs_entries(), m_request_header(), m_object_heap(), m_buffers(), m_send_object_id(), m_session_open(), m_cached_object_sizes(), m_object_database() { /* ... */ }
 
             Result Initialize(EventReactor *reactor, PtpObjectHeap *object_heap, const FsEntries& entries, u16 vid, u16 pid);
             void Finalize();
@@ -109,6 +112,11 @@ namespace haze {
             void WriteCallbackFile(CallbackType type, const char* name);
             void WriteCallbackRename(CallbackType type, const char* name, const char* newname);
             void WriteCallbackProgress(CallbackType type, s64 offset, s64 size);
+
+            void CacheObjectSizeByName(const char* name, u64 size);
+            void CacheObjectSize(const PtpObject* obj, u64 size);
+            bool TryGetCachedObjectSize(const PtpObject* obj, s64* out_size) const;
+            void EraseCachedObjectSize(const char* name);
     };
 
 }
diff --git a/external/libhaze/source/ptp_responder.cpp b/external/libhaze/source/ptp_responder.cpp
index e57fe3c..0603fbc 100644
--- a/external/libhaze/source/ptp_responder.cpp
+++ b/external/libhaze/source/ptp_responder.cpp
@@ -40,6 +40,7 @@ namespace haze {
         m_object_heap = object_heap;
         m_buffers = GetBuffers();
         m_fs_entries.clear();
+        m_cached_object_sizes.clear();
 
         u32 storage_id = StorageId_DefaultStorage;
 
@@ -165,6 +166,7 @@ namespace haze {
         if (m_session_open) {
             m_session_open = false;
             m_object_database.Finalize();
+            m_cached_object_sizes.clear();
         }
     }
 
@@ -181,6 +183,41 @@ namespace haze {
         R_RETURN(db.Commit());
     }
 
+    void PtpResponder::CacheObjectSizeByName(const char* name, u64 size) {
+        if (!name || name[0] == '\0') {
+            return;
+        }
+        m_cached_object_sizes[std::string(name)] = size;
+    }
+
+    void PtpResponder::CacheObjectSize(const PtpObject* obj, u64 size) {
+        if (!obj) {
+            return;
+        }
+        this->CacheObjectSizeByName(obj->GetName(), size);
+    }
+
+    bool PtpResponder::TryGetCachedObjectSize(const PtpObject* obj, s64* out_size) const {
+        if (!obj || !out_size) {
+            return false;
+        }
+
+        const auto it = m_cached_object_sizes.find(std::string(obj->GetName()));
+        if (it == m_cached_object_sizes.end()) {
+            return false;
+        }
+
+        *out_size = static_cast<s64>(it->second);
+        return true;
+    }
+
+    void PtpResponder::EraseCachedObjectSize(const char* name) {
+        if (!name || name[0] == '\0') {
+            return;
+        }
+        m_cached_object_sizes.erase(std::string(name));
+    }
+
     #if 0
     void PtpResponder::WriteCallbackSession(CallbackType type) {}
     void PtpResponder::WriteCallbackFile(CallbackType type, const char* name) {}
diff --git a/external/libhaze/source/ptp_responder_mtp_operations.cpp b/external/libhaze/source/ptp_responder_mtp_operations.cpp
index d993142..f73c3a1 100644
--- a/external/libhaze/source/ptp_responder_mtp_operations.cpp
+++ b/external/libhaze/source/ptp_responder_mtp_operations.cpp
@@ -144,6 +144,10 @@ namespace haze {
             /* If it is, we're done. */
             R_SUCCEED_IF(entry_type == FsDirEntryType_Dir);
 
+            if (this->TryGetCachedObjectSize(obj, out_size)) {
+                R_SUCCEED();
+            }
+
             /* Otherwise, open as a file. */
             FsFile file;
             R_TRY(Fs(obj).OpenFile(obj->GetName(), FsOpenMode_Read, std::addressof(file)));
@@ -151,7 +155,9 @@ namespace haze {
             /* Ensure we maintain a clean state on exit. */
             ON_SCOPE_EXIT { Fs(obj).CloseFile(std::addressof(file)); };
 
-            R_RETURN(Fs(obj).GetFileSize(std::addressof(file), out_size));
+            R_TRY(Fs(obj).GetFileSize(std::addressof(file), out_size));
+            this->CacheObjectSize(obj, static_cast<u64>(*out_size));
+            R_SUCCEED();
         };
 
         /* Begin writing the requested object property. */
@@ -249,6 +255,10 @@ namespace haze {
             /* If it is, we're done. */
             R_SUCCEED_IF(entry_type == FsDirEntryType_Dir);
 
+            if (this->TryGetCachedObjectSize(obj, out_size)) {
+                R_SUCCEED();
+            }
+
             /* Otherwise, open as a file. */
             FsFile file;
             R_TRY(Fs(obj).OpenFile(obj->GetName(), FsOpenMode_Read, std::addressof(file)));
@@ -256,7 +266,9 @@ namespace haze {
             /* Ensure we maintain a clean state on exit. */
             ON_SCOPE_EXIT { Fs(obj).CloseFile(std::addressof(file)); };
 
-            R_RETURN(Fs(obj).GetFileSize(std::addressof(file), out_size));
+            R_TRY(Fs(obj).GetFileSize(std::addressof(file), out_size));
+            this->CacheObjectSize(obj, static_cast<u64>(*out_size));
+            R_SUCCEED();
         };
 
         /* Define helper for determining if the property should be included. */
@@ -449,6 +461,7 @@ namespace haze {
             R_TRY(Fs(newobj).CreateFile(newobj->GetName(), prop_list.size, flags));
             WriteCallbackFile(CallbackType_CreateFile, newobj->GetName());
             m_send_object_id = new_object_info.object_id;
+            this->CacheObjectSize(newobj, prop_list.size);
         }
 
         /* Save prop list and return success. */
@@ -528,10 +541,16 @@ namespace haze {
         }
 
         /* Unregister and free the old object. */
+        s64 cached_size = 0;
+        const bool had_cached_size = this->TryGetCachedObjectSize(obj, std::addressof(cached_size));
+        this->EraseCachedObjectSize(obj->GetName());
         m_object_database.DeleteObject(obj);
 
         /* Register the new object. */
         m_object_database.RegisterObject(newobj, object_id);
+        if (had_cached_size && cached_size >= 0) {
+            this->CacheObjectSize(newobj, static_cast<u64>(cached_size));
+        }
 
         /* Write the success response. */
         R_RETURN(this->WriteResponse(PtpResponseCode_Ok));
diff --git a/external/libhaze/source/ptp_responder_ptp_operations.cpp b/external/libhaze/source/ptp_responder_ptp_operations.cpp
index 5b71b94..d661d62 100644
--- a/external/libhaze/source/ptp_responder_ptp_operations.cpp
+++ b/external/libhaze/source/ptp_responder_ptp_operations.cpp
@@ -128,6 +128,12 @@ namespace haze {
         storage_info.free_space_in_bytes  = free_space;
         storage_info.free_space_in_images = 0;
         storage_info.storage_description = it->impl->GetDisplayName();
+        {
+            const u16 cap = it->impl->GetAccessCapability();
+            if (cap <= static_cast<u16>(PtpAccessCapability_ReadOnlyWithObjectDeletion)) {
+                storage_info.access_capability = static_cast<PtpAccessCapability>(cap);
+            }
+        }
 
         /* Write the storage info data. */
         R_TRY(db.WriteVariableLengthData(m_request_header, [&] () {
@@ -178,29 +184,30 @@ namespace haze {
         /* Ensure we maintain a clean state on exit. */
         ON_SCOPE_EXIT { Fs(obj).CloseDirectory(std::addressof(dir)); };
 
-        /* Count how many entries are in the directory. */
-        s64 entry_count = 0;
-        R_TRY(Fs(obj).GetDirectoryEntryCount(std::addressof(dir), std::addressof(entry_count)));
-
-        /* Begin writing. */
-        R_TRY(db.AddDataHeader(m_request_header, sizeof(u32) + (entry_count * sizeof(u32))));
-        R_TRY(db.Add(static_cast<u32>(entry_count)));
-
-        /* Enumerate the directory, writing results to the data builder as we progress. */
-        /* TODO: How should we handle the directory contents changing during enumeration? */
-        /* Is this even feasible to handle? */
+        /* Enumerate first, then emit header once we know exact handle count.
+         * This avoids relying on GetDirectoryEntryCount() behavior across all fs backends. */
+        std::vector<u32> handles;
+        handles.reserve(256);
         while (true) {
             /* Get the next batch. */
             s64 read_count = 0;
             R_TRY(Fs(obj).ReadDirectory(std::addressof(dir), std::addressof(read_count), DirectoryReadSize, m_buffers->file_system_entry_buffer));
 
-            /* Write to output. */
+            /* Build handle list. */
             for (s64 i = 0; i < read_count; i++) {
-                const char *name = m_buffers->file_system_entry_buffer[i].name;
+                const auto &entry = m_buffers->file_system_entry_buffer[i];
+                const char *name = entry.name;
                 u32 handle;
 
                 R_TRY(m_object_database.CreateAndRegisterObjectId(obj->GetName(), name, obj->GetObjectId(), obj->GetStorageId(), std::addressof(handle)));
-                R_TRY(db.Add(handle));
+                handles.push_back(handle);
+
+                if (entry.type == FsDirEntryType_File && entry.file_size >= 0) {
+                    auto * const child = m_object_database.GetObjectById(handle);
+                    if (child != nullptr) {
+                        this->CacheObjectSize(child, static_cast<u64>(entry.file_size));
+                    }
+                }
             }
 
             /* If we read fewer than the batch size, we're done. */
@@ -209,6 +216,13 @@ namespace haze {
             }
         }
 
+        /* Begin writing. */
+        R_TRY(db.AddDataHeader(m_request_header, sizeof(u32) + (handles.size() * sizeof(u32))));
+        R_TRY(db.Add(static_cast<u32>(handles.size())));
+        for (const auto handle : handles) {
+            R_TRY(db.Add(handle));
+        }
+
         /* Flush the data response. */
         R_TRY(db.Commit());
 
@@ -248,13 +262,15 @@ namespace haze {
             /* Get the size, if we are requesting info about a file. */
             s64 size = 0;
             if (entry_type == FsDirEntryType_File) {
-                FsFile file;
-                R_TRY(Fs(obj).OpenFile(obj->GetName(), FsOpenMode_Read, std::addressof(file)));
-
-                /* Ensure we maintain a clean state on exit. */
-                ON_SCOPE_EXIT { Fs(obj).CloseFile(std::addressof(file)); };
-
-                R_TRY(Fs(obj).GetFileSize(std::addressof(file), std::addressof(size)));
+                if (!this->TryGetCachedObjectSize(obj, std::addressof(size))) {
+                    FsFile file;
+                    /* Ensure we maintain a clean state on exit. */
+                    R_TRY(Fs(obj).OpenFile(obj->GetName(), FsOpenMode_Read, std::addressof(file)));
+                    ON_SCOPE_EXIT { Fs(obj).CloseFile(std::addressof(file)); };
+
+                    R_TRY(Fs(obj).GetFileSize(std::addressof(file), std::addressof(size)));
+                    this->CacheObjectSize(obj, static_cast<u64>(size));
+                }
             }
 
             object_info.filename               = std::strrchr(obj->GetName(), '/') + 1;
@@ -326,6 +342,7 @@ namespace haze {
         /* Get the file's size. */
         s64 file_size = 0;
         R_TRY(Fs(obj).GetFileSize(std::addressof(file), std::addressof(file_size)));
+        this->CacheObjectSize(obj, static_cast<u64>(file_size));
 
         /* Send the header and file size. */
         R_TRY(db.AddDataHeader(m_request_header, file_size));
@@ -335,7 +352,7 @@ namespace haze {
 
         auto mode = sphaira::thread::Mode::MultiThreaded;
         if (!Fs(obj).MultiThreadTransfer(file_size, true)) {
-            mode = sphaira::thread::Mode::SingleThreadedIfSmaller;
+            mode = sphaira::thread::Mode::SingleThreaded;
         }
 
         R_TRY(sphaira::thread::Transfer(file_size,
@@ -435,6 +452,7 @@ namespace haze {
             R_TRY(Fs(obj).CreateFile(obj->GetName(), 0, 0));
             WriteCallbackFile(CallbackType_CreateFile, obj->GetName());
             m_send_object_id = new_object_info.object_id;
+            this->CacheObjectSize(obj, static_cast<u64>(info.object_compressed_size));
         }
 
         /* Write the success response. */
@@ -472,8 +490,9 @@ namespace haze {
             }
         };
 
-        /* Dummy file size for the threaded transfer. */
-        auto file_size = 4_GB;
+        /* Fallback size when host does not provide object size metadata.
+         * Must be comfortably above common install file sizes to avoid early truncation. */
+        auto file_size = 128_GB;
         u64 offset = 0;
 
         if (m_send_prop_list) {
@@ -544,6 +563,7 @@ namespace haze {
             R_TRY(Fs(obj).SetFileSize(std::addressof(file), offset));
             file_size = offset;
         }
+        this->CacheObjectSize(obj, static_cast<u64>(file_size));
 
         /* Ensure file close/finalize happens before acknowledging success to host. */
         WriteCallbackFile(CallbackType_WriteEnd, obj->GetName());
@@ -585,6 +605,7 @@ namespace haze {
         }
 
         /* Remove the object from the database. */
+        this->EraseCachedObjectSize(obj->GetName());
         m_object_database.DeleteObject(obj);
 
         /* Write the success response. */
diff --git a/external/libhaze/source/threaded_file_transfer.cpp b/external/libhaze/source/threaded_file_transfer.cpp
index a5c1ebc..5f719b5 100644
--- a/external/libhaze/source/threaded_file_transfer.cpp
+++ b/external/libhaze/source/threaded_file_transfer.cpp
@@ -9,7 +9,7 @@
 namespace sphaira::thread {
 namespace {
 
-constexpr u64 BUFFER_SIZE = 1024*1024*1;
+constexpr u64 BUFFER_SIZE = 1024*1024*4;
 
 struct ThreadBuffer {
     ThreadBuffer() {
@@ -110,7 +110,7 @@ private:
     CondVar can_read{};
     CondVar can_write{};
 
-    RingBuf<2> write_buffers{};
+    RingBuf<4> write_buffers{};
 
     const u64 read_buffer_size;
     const s64 write_size;
diff --git a/source/mtp_install.cpp b/source/mtp_install.cpp
index 99e2bb7..f869a7f 100644
--- a/source/mtp_install.cpp
+++ b/source/mtp_install.cpp
@@ -6,11 +6,15 @@
 #include <atomic>
 #include <condition_variable>
 #include <cstddef>
+#include <cstdarg>
+#include <cstdio>
+#include <filesystem>
 #include <memory>
 #include <mutex>
 #include <string>
 #include <thread>
 #include <unordered_map>
+#include <unordered_set>
 #include <vector>
 
 #include "switch.h"
@@ -48,6 +52,59 @@ std::atomic<std::uint64_t> g_stream_received{0};
 std::atomic<std::uint64_t> g_stream_title_id{0};
 std::mutex g_stream_mutex;
 std::string g_stream_name;
+std::mutex g_stream_trace_mutex;
+std::atomic<u64> g_stream_trace_count{0};
+std::atomic<u64> g_stream_write_calls{0};
+std::atomic<bool> g_stream_trace_enabled{false};
+constexpr u64 kStreamTraceMaxLines = 60000;
+constexpr const char* kStreamTracePath = "sdmc:/switch/CyberFoil/mtp_install_debug.log";
+constexpr const char* kStreamTraceEnablePath = "sdmc:/switch/CyberFoil/mtp_install_debug.enable";
+
+bool IsStreamTraceEnabled() {
+    return g_stream_trace_enabled.load(std::memory_order_relaxed);
+}
+
+u64 TicksToMs(u64 ticks) {
+    const u64 freq = armGetSystemTickFreq();
+    if (freq == 0) {
+        return 0;
+    }
+    return (ticks * 1000ULL) / freq;
+}
+
+void StreamTrace(const char* fmt, ...) {
+    if (!IsStreamTraceEnabled()) {
+        return;
+    }
+    const u64 idx = g_stream_trace_count.fetch_add(1, std::memory_order_relaxed);
+    if (idx >= kStreamTraceMaxLines) {
+        return;
+    }
+
+    char msg[512] = {};
+    va_list args;
+    va_start(args, fmt);
+    std::vsnprintf(msg, sizeof(msg), fmt, args);
+    va_end(args);
+
+    std::lock_guard<std::mutex> lock(g_stream_trace_mutex);
+    FILE* f = std::fopen(kStreamTracePath, "ab");
+    if (!f) {
+        return;
+    }
+    std::fprintf(f, "%llu %s\n", static_cast<unsigned long long>(idx), msg);
+    std::fclose(f);
+}
+
+void ResetStreamTrace() {
+    if (!IsStreamTraceEnabled()) {
+        return;
+    }
+    std::lock_guard<std::mutex> lock(g_stream_trace_mutex);
+    std::remove(kStreamTracePath);
+    g_stream_trace_count.store(0, std::memory_order_relaxed);
+    g_stream_write_calls.store(0, std::memory_order_relaxed);
+}
 
 class StreamInstaller {
 public:
@@ -166,6 +223,7 @@ bool MtpNspStream::ParseHeaderIfReady()
 
     const auto* base = reinterpret_cast<const tin::install::PFS0BaseHeader*>(m_header_bytes.data());
     if (base->magic != 0x30534650) {
+        StreamTrace("NSP ParseHeader invalid magic=0x%08x", base->magic);
         THROW_FORMAT("Invalid PFS0 magic");
     }
 
@@ -200,6 +258,10 @@ bool MtpNspStream::ParseHeaderIfReady()
     std::sort(m_entries.begin(), m_entries.end(), [](const EntryState& a, const EntryState& b) {
         return a.data_offset < b.data_offset;
     });
+    StreamTrace("NSP ParseHeader parsed files=%u header=%zu total=%llu",
+        static_cast<unsigned>(base->numFiles),
+        header_size,
+        static_cast<unsigned long long>(m_total_size));
 
     return true;
 }
@@ -218,6 +280,10 @@ bool MtpNspStream::EnsureEntryStarted(EntryState& entry)
     } catch (...) {}
     entry.nca_writer = std::make_unique<NcaWriter>(entry.nca_id, entry.storage);
     entry.started = true;
+    StreamTrace("NSP EntryStart name='%s' size=%llu cnmt=%d",
+        entry.name.c_str(),
+        static_cast<unsigned long long>(entry.size),
+        entry.is_cnmt ? 1 : 0);
     return true;
 }
 
@@ -239,8 +305,12 @@ bool MtpNspStream::CommitCnmt(EntryState& entry)
         cnmt_info.content_type = NcmContentType_Meta;
         m_helper->AddContentMeta(meta, cnmt_info);
         m_helper->CommitLatest();
+        StreamTrace("NSP CommitCnmt ok name='%s' size=%llu",
+            entry.name.c_str(),
+            static_cast<unsigned long long>(entry.size));
         return true;
     } catch (...) {
+        StreamTrace("NSP CommitCnmt fail name='%s'", entry.name.c_str());
         return false;
     }
 }
@@ -258,6 +328,11 @@ bool MtpNspStream::WriteEntryData(EntryState& entry, const std::uint8_t* data, s
                 return true;
             }
         } else {
+            StreamTrace("NSP WriteEntryData gap name='%s' rel=%llu written=%llu size=%zu",
+                entry.name.c_str(),
+                static_cast<unsigned long long>(rel_offset),
+                static_cast<unsigned long long>(entry.written),
+                size);
             return false;
         }
     }
@@ -301,6 +376,9 @@ bool MtpNspStream::WriteEntryData(EntryState& entry, const std::uint8_t* data, s
         if (entry.is_cnmt) {
             CommitCnmt(entry);
         }
+        StreamTrace("NSP EntryComplete name='%s' size=%llu",
+            entry.name.c_str(),
+            static_cast<unsigned long long>(entry.size));
     }
     return true;
 }
@@ -366,13 +444,24 @@ bool MtpNspStream::Feed(const void* buf, size_t size, std::uint64_t offset)
         const auto rel = write_start - chunk_start;
         const auto write_size = static_cast<size_t>(write_end - write_start);
 
-        if (!EnsureEntryStarted(entry)) return false;
+        if (!EnsureEntryStarted(entry)) {
+            StreamTrace("NSP EnsureEntryStarted fail name='%s'", entry.name.c_str());
+            return false;
+        }
         const auto entry_rel = write_start - entry_start;
-        if (!WriteEntryData(entry, data + rel, write_size, entry_rel)) return false;
+        if (!WriteEntryData(entry, data + rel, write_size, entry_rel)) {
+            StreamTrace("NSP WriteEntryData fail name='%s' entry_rel=%llu write_size=%zu",
+                entry.name.c_str(),
+                static_cast<unsigned long long>(entry_rel),
+                write_size);
+            return false;
+        }
     }
 
     return true;
     } catch (...) {
+        StreamTrace("NSP Feed exception off=%llu size=%zu",
+            static_cast<unsigned long long>(offset), size);
         return false;
     }
 }
@@ -380,25 +469,44 @@ bool MtpNspStream::Feed(const void* buf, size_t size, std::uint64_t offset)
 bool MtpNspStream::Finalize()
 {
     if (!m_helper) return true;
+    StreamTrace("NSP Finalize begin entries=%zu", m_entries.size());
     bool ok = true;
 
-    std::vector<std::vector<std::uint8_t>> tickets;
-    std::vector<std::vector<std::uint8_t>> certs;
+    std::unordered_map<std::string, std::vector<std::uint8_t>> tickets_by_base;
+    std::unordered_map<std::string, std::vector<std::uint8_t>> certs_by_base;
     for (const auto& entry : m_entries) {
-        if (entry.name.find(".tik") != std::string::npos) {
-            tickets.push_back(entry.ticket_buf);
+        const auto tik_pos = entry.name.rfind(".tik");
+        if (tik_pos != std::string::npos && tik_pos + 4 == entry.name.size()) {
+            tickets_by_base[entry.name.substr(0, tik_pos)] = entry.ticket_buf;
         }
-        if (entry.name.find(".cert") != std::string::npos) {
-            certs.push_back(entry.cert_buf);
+        const auto cert_pos = entry.name.rfind(".cert");
+        if (cert_pos != std::string::npos && cert_pos + 5 == entry.name.size()) {
+            certs_by_base[entry.name.substr(0, cert_pos)] = entry.cert_buf;
         }
     }
 
-    const size_t count = std::min(tickets.size(), certs.size());
-    for (size_t i = 0; i < count; i++) {
-        if (!tickets[i].empty() && !certs[i].empty()) {
-            const Result rc = esImportTicket(tickets[i].data(), tickets[i].size(), certs[i].data(), certs[i].size());
+    std::unordered_set<std::string> base_names;
+    base_names.reserve(tickets_by_base.size() + certs_by_base.size());
+    for (const auto& entry : tickets_by_base) {
+        base_names.insert(entry.first);
+    }
+    for (const auto& entry : certs_by_base) {
+        base_names.insert(entry.first);
+    }
+
+    for (const auto& base : base_names) {
+        const auto tik_it = tickets_by_base.find(base);
+        const auto cert_it = certs_by_base.find(base);
+        if (tik_it == tickets_by_base.end() || cert_it == certs_by_base.end()) {
+            continue;
+        }
+        if (!tik_it->second.empty() && !cert_it->second.empty()) {
+            const Result rc = esImportTicket(
+                tik_it->second.data(), tik_it->second.size(),
+                cert_it->second.data(), cert_it->second.size());
             if (R_FAILED(rc)) {
                 LOG_DEBUG("MTP finalize: ticket import failed (0x%08x)\n", rc);
+                StreamTrace("NSP Finalize ticket import fail base='%s' rc=0x%08x", base.c_str(), rc);
                 ok = false;
             }
         }
@@ -408,30 +516,39 @@ bool MtpNspStream::Finalize()
         m_helper->CommitAll();
     } catch (const std::exception& e) {
         LOG_DEBUG("MTP finalize: CommitAll failed: %s\n", e.what());
+        StreamTrace("NSP Finalize CommitAll exception='%s'", e.what());
         ok = false;
     } catch (...) {
         LOG_DEBUG("MTP finalize: CommitAll failed with unknown exception\n");
+        StreamTrace("NSP Finalize CommitAll unknown exception");
         ok = false;
     }
+    StreamTrace("NSP Finalize end ok=%d", ok ? 1 : 0);
     return ok;
 }
 
 class MtpStreamBuffer {
 public:
-    explicit MtpStreamBuffer(size_t max_size) : m_max_size(max_size) {}
+    explicit MtpStreamBuffer(size_t max_size)
+        : m_storage(max_size), m_max_size(max_size) {}
 
     bool Push(const void* buf, size_t size) {
+        if (m_max_size == 0) return false;
         const auto* data = static_cast<const std::uint8_t*>(buf);
         while (size > 0) {
             std::unique_lock<std::mutex> lock(m_mutex);
-            m_can_write.wait(lock, [&]() { return !m_active || m_buffer.size() < m_max_size; });
+            m_can_write.wait(lock, [&]() { return !m_active || m_size < m_max_size; });
             if (!m_active) return false;
 
-            const size_t writable = m_max_size - m_buffer.size();
+            const size_t writable = m_max_size - m_size;
             const size_t chunk = std::min<size_t>(size, writable);
-            const size_t offset = m_buffer.size();
-            m_buffer.resize(offset + chunk);
-            std::memcpy(m_buffer.data() + offset, data, chunk);
+            const size_t first = std::min<size_t>(chunk, m_max_size - m_write_pos);
+            std::memcpy(m_storage.data() + m_write_pos, data, first);
+            if (chunk > first) {
+                std::memcpy(m_storage.data(), data + first, chunk - first);
+            }
+            m_write_pos = (m_write_pos + chunk) % m_max_size;
+            m_size += chunk;
             data += chunk;
             size -= chunk;
             lock.unlock();
@@ -441,19 +558,25 @@ public:
     }
 
     bool ReadChunk(void* buf, size_t size, u64* out_read) {
+        if (m_max_size == 0) return false;
         auto* out = static_cast<std::uint8_t*>(buf);
         *out_read = 0;
         std::unique_lock<std::mutex> lock(m_mutex);
-        while (m_active && m_buffer.empty()) {
+        while (m_active && m_size == 0) {
             m_can_read.wait(lock);
         }
-        if (!m_active && m_buffer.empty()) {
+        if (!m_active && m_size == 0) {
             return false;
         }
 
-        const size_t chunk = std::min<size_t>(size, m_buffer.size());
-        std::memcpy(out, m_buffer.data(), chunk);
-        m_buffer.erase(m_buffer.begin(), m_buffer.begin() + chunk);
+        const size_t chunk = std::min<size_t>(size, m_size);
+        const size_t first = std::min<size_t>(chunk, m_max_size - m_read_pos);
+        std::memcpy(out, m_storage.data() + m_read_pos, first);
+        if (chunk > first) {
+            std::memcpy(out + first, m_storage.data(), chunk - first);
+        }
+        m_read_pos = (m_read_pos + chunk) % m_max_size;
+        m_size -= chunk;
         *out_read = chunk;
         lock.unlock();
         m_can_write.notify_one();
@@ -467,41 +590,57 @@ public:
         m_can_write.notify_all();
     }
 
+    size_t GetBufferedSize() const {
+        std::lock_guard<std::mutex> lock(m_mutex);
+        return m_size;
+    }
+
 private:
-    std::mutex m_mutex;
+    mutable std::mutex m_mutex;
     std::condition_variable m_can_read;
     std::condition_variable m_can_write;
-    std::vector<std::uint8_t> m_buffer;
+    std::vector<std::uint8_t> m_storage;
     size_t m_max_size = 0;
+    size_t m_size = 0;
+    size_t m_read_pos = 0;
+    size_t m_write_pos = 0;
     bool m_active = true;
 };
 
 class MtpStreamSource {
 public:
-    explicit MtpStreamSource(MtpStreamBuffer& buffer) : m_buffer(buffer) {}
+    explicit MtpStreamSource(MtpStreamBuffer& buffer)
+        : m_buffer(buffer), m_temp(0x400000) {}
 
     Result Read(void* buf, s64 off, s64 size, u64* bytes_read) {
-        if (off < m_offset) return MAKERESULT(Module_Libnx, LibnxError_BadInput);
+        if (off < m_offset) {
+            StreamTrace("XCI SourceRead bad off=%lld cur=%lld size=%lld",
+                static_cast<long long>(off),
+                static_cast<long long>(m_offset),
+                static_cast<long long>(size));
+            return MAKERESULT(Module_Libnx, LibnxError_BadInput);
+        }
 
         auto* out = static_cast<std::uint8_t*>(buf);
         *bytes_read = 0;
-        std::vector<std::uint8_t> temp(0x10000);
 
         while (size > 0) {
             if (off > m_offset) {
                 const auto skip = static_cast<s64>(off - m_offset);
-                const auto chunk = static_cast<size_t>(std::min<s64>(skip, static_cast<s64>(temp.size())));
+                const auto chunk = static_cast<size_t>(std::min<s64>(skip, static_cast<s64>(m_temp.size())));
                 u64 read = 0;
-                if (!m_buffer.ReadChunk(temp.data(), chunk, &read)) {
+                if (!m_buffer.ReadChunk(m_temp.data(), chunk, &read)) {
+                    StreamTrace("XCI SourceRead skip failed off=%lld chunk=%zu", static_cast<long long>(off), chunk);
                     return KERNELRESULT(NotImplemented);
                 }
                 m_offset += static_cast<s64>(read);
                 continue;
             }
 
-            const auto chunk = static_cast<size_t>(std::min<s64>(size, static_cast<s64>(temp.size())));
+            const auto chunk = static_cast<size_t>(std::min<s64>(size, static_cast<s64>(m_temp.size())));
             u64 read = 0;
             if (!m_buffer.ReadChunk(out, chunk, &read)) {
+                StreamTrace("XCI SourceRead data failed off=%lld chunk=%zu", static_cast<long long>(off), chunk);
                 return KERNELRESULT(NotImplemented);
             }
             *bytes_read += read;
@@ -517,6 +656,7 @@ public:
 private:
     MtpStreamBuffer& m_buffer;
     s64 m_offset = 0;
+    std::vector<std::uint8_t> m_temp;
 };
 
 struct StreamHfs0Header {
@@ -608,12 +748,20 @@ static bool GetXciCollections(MtpStreamSource& source, std::vector<StreamCollect
 class MtpXciStreamPull final : public StreamInstaller {
 public:
     explicit MtpXciStreamPull(std::uint64_t total_size, NcmStorageId dest_storage)
-        : m_dest_storage(dest_storage), m_total_size(total_size), m_buffer(1024 * 1024) {
+        : m_dest_storage(dest_storage), m_total_size(total_size), m_buffer(8 * 1024 * 1024) {
         m_helper = std::make_unique<StreamInstallHelper>(dest_storage, inst::config::ignoreReqVers);
+        StreamTrace("XCI ctor total=%llu storage=%u",
+            static_cast<unsigned long long>(total_size),
+            static_cast<unsigned>(dest_storage));
         m_thread = std::thread([this]() {
             MtpStreamSource source(m_buffer);
-            m_ok.store(InstallFromSource(source), std::memory_order_relaxed);
+            const bool ok = InstallFromSource(source);
+            m_ok.store(ok, std::memory_order_relaxed);
             m_done.store(true, std::memory_order_relaxed);
+            StreamTrace("XCI worker done ok=%d received=%llu buffered=%zu",
+                ok ? 1 : 0,
+                static_cast<unsigned long long>(m_received),
+                m_buffer.GetBufferedSize());
             m_buffer.Disable();
         });
     }
@@ -623,10 +771,12 @@ public:
         if (m_thread.joinable()) {
             m_thread.join();
         }
+        StreamTrace("XCI dtor");
     }
 
     bool Feed(const void* buf, size_t size, std::uint64_t /*offset*/) override {
         if (size == 0) return true;
+        const u64 t0 = armGetSystemTick();
         m_received += size;
         if (m_total_size) {
             const auto current = g_stream_received.load(std::memory_order_relaxed);
@@ -634,15 +784,32 @@ public:
                 g_stream_received.store(m_received, std::memory_order_relaxed);
             }
         }
-        return m_buffer.Push(buf, size);
+        const bool ok = m_buffer.Push(buf, size);
+        const u64 dt_ms = TicksToMs(armGetSystemTick() - t0);
+        if (!ok || dt_ms >= 250 || (m_received % (64ULL * 1024ULL * 1024ULL) < size)) {
+            StreamTrace("XCI Feed size=%zu ok=%d dt_ms=%llu received=%llu buffered=%zu",
+                size,
+                ok ? 1 : 0,
+                static_cast<unsigned long long>(dt_ms),
+                static_cast<unsigned long long>(m_received),
+                m_buffer.GetBufferedSize());
+        }
+        return ok;
     }
 
     bool Finalize() override {
+        StreamTrace("XCI Finalize begin received=%llu buffered=%zu",
+            static_cast<unsigned long long>(m_received),
+            m_buffer.GetBufferedSize());
         m_buffer.Disable();
         if (m_thread.joinable()) {
             m_thread.join();
         }
-        return m_ok.load(std::memory_order_relaxed);
+        const bool ok = m_ok.load(std::memory_order_relaxed);
+        StreamTrace("XCI Finalize end ok=%d done=%d",
+            ok ? 1 : 0,
+            m_done.load(std::memory_order_relaxed) ? 1 : 0);
+        return ok;
     }
 
 private:
@@ -737,7 +904,11 @@ private:
 
     bool InstallFromSource(MtpStreamSource& source) {
         std::vector<StreamCollectionEntry> collections;
-        if (!GetXciCollections(source, collections)) return false;
+        if (!GetXciCollections(source, collections)) {
+            StreamTrace("XCI InstallFromSource GetXciCollections failed");
+            return false;
+        }
+        StreamTrace("XCI InstallFromSource collections=%zu", collections.size());
 
         std::sort(collections.begin(), collections.end(), [](const auto& a, const auto& b) {
             return a.offset < b.offset;
@@ -745,6 +916,7 @@ private:
 
         std::unordered_map<std::string, EntryState> entries;
         entries.reserve(collections.size());
+        std::vector<std::uint8_t> buf(0x400000);
 
         for (const auto& collection : collections) {
             EntryState entry;
@@ -756,23 +928,44 @@ private:
                 entry.nca_id = tin::util::GetNcaIdFromString(entry.name.substr(0, 32));
             }
 
-            if (!EnsureEntryStarted(entry)) return false;
+            if (!EnsureEntryStarted(entry)) {
+                StreamTrace("XCI EnsureEntryStarted fail name='%s'", entry.name.c_str());
+                return false;
+            }
 
             u64 remaining = collection.size;
             u64 offset = collection.offset;
-            std::vector<std::uint8_t> buf(0x400000);
+            StreamTrace("XCI Collection start name='%s' off=%llu size=%llu",
+                entry.name.c_str(),
+                static_cast<unsigned long long>(collection.offset),
+                static_cast<unsigned long long>(collection.size));
             while (remaining > 0) {
                 const auto chunk = static_cast<size_t>(std::min<u64>(remaining, buf.size()));
                 u64 bytes_read = 0;
                 if (R_FAILED(source.Read(buf.data(), static_cast<s64>(offset), static_cast<s64>(chunk), &bytes_read))) {
+                    StreamTrace("XCI Source.Read fail name='%s' off=%llu chunk=%zu",
+                        entry.name.c_str(),
+                        static_cast<unsigned long long>(offset),
+                        chunk);
+                    return false;
+                }
+                if (bytes_read == 0) {
+                    StreamTrace("XCI Source.Read eof name='%s' off=%llu", entry.name.c_str(), static_cast<unsigned long long>(offset));
+                    return false;
+                }
+                if (!WriteEntryData(entry, buf.data(), static_cast<size_t>(bytes_read))) {
+                    StreamTrace("XCI WriteEntryData fail name='%s' bytes=%llu",
+                        entry.name.c_str(),
+                        static_cast<unsigned long long>(bytes_read));
                     return false;
                 }
-                if (bytes_read == 0) return false;
-                if (!WriteEntryData(entry, buf.data(), static_cast<size_t>(bytes_read))) return false;
                 offset += bytes_read;
                 remaining -= bytes_read;
             }
 
+            StreamTrace("XCI Collection done name='%s' size=%llu",
+                entry.name.c_str(),
+                static_cast<unsigned long long>(entry.size));
             entries.emplace(entry.name, std::move(entry));
         }
 
@@ -784,6 +977,7 @@ private:
                     const Result rc = esImportTicket(entry.ticket_buf.data(), entry.ticket_buf.size(), it->second.cert_buf.data(), it->second.cert_buf.size());
                     if (R_FAILED(rc)) {
                         LOG_DEBUG("MTP XCI finalize: ticket import failed (0x%08x)\n", rc);
+                        StreamTrace("XCI ticket import fail base='%s' rc=0x%08x", base.c_str(), rc);
                         return false;
                     }
                 }
@@ -792,12 +986,15 @@ private:
 
         try {
             m_helper->CommitAll();
+            StreamTrace("XCI CommitAll ok");
             return true;
         } catch (const std::exception& e) {
             LOG_DEBUG("MTP XCI finalize: CommitAll failed: %s\n", e.what());
+            StreamTrace("XCI CommitAll exception='%s'", e.what());
             return false;
         } catch (...) {
             LOG_DEBUG("MTP XCI finalize: CommitAll failed with unknown exception\n");
+            StreamTrace("XCI CommitAll unknown exception");
             return false;
         }
     }
@@ -816,46 +1013,86 @@ private:
 
 bool StartStreamInstall(const std::string& name, std::uint64_t size, int storage_choice)
 {
+    g_stream_trace_enabled.store(std::filesystem::exists(kStreamTraceEnablePath), std::memory_order_relaxed);
+    ResetStreamTrace();
+    StreamTrace("Start name='%s' size=%llu storage_choice=%d",
+        name.c_str(),
+        static_cast<unsigned long long>(size),
+        storage_choice);
     {
         std::lock_guard<std::mutex> lock(g_stream_mutex);
         g_stream.reset();
     }
 
-    g_stream_total.store(size, std::memory_order_relaxed);
-    g_stream_received.store(0, std::memory_order_relaxed);
-    g_stream_active.store(true, std::memory_order_relaxed);
-    g_stream_complete.store(false, std::memory_order_relaxed);
-    g_stream_title_id.store(0, std::memory_order_relaxed);
-    {
-        std::lock_guard<std::mutex> lock(g_stream_mutex);
-        g_stream_name = name;
-    }
-
     NcmStorageId storage = (storage_choice == 1) ? NcmStorageId_BuiltInUser : NcmStorageId_SdCard;
     {
         std::lock_guard<std::mutex> lock(g_stream_mutex);
+        g_stream_name = name;
         if (IsNspName(name)) {
             g_stream = std::make_unique<MtpNspStream>(size, storage);
+            StreamTrace("Start stream_type=NSP");
         } else if (IsXciName(name)) {
             g_stream = std::make_unique<MtpXciStreamPull>(size, storage);
+            StreamTrace("Start stream_type=XCI");
         } else {
+            g_stream_name.clear();
+            g_stream_total.store(0, std::memory_order_relaxed);
+            g_stream_received.store(0, std::memory_order_relaxed);
+            g_stream_active.store(false, std::memory_order_relaxed);
+            g_stream_complete.store(false, std::memory_order_relaxed);
+            g_stream_title_id.store(0, std::memory_order_relaxed);
+            StreamTrace("Start unsupported extension name='%s'", name.c_str());
             return false;
         }
     }
 
+    g_stream_total.store(size, std::memory_order_relaxed);
+    g_stream_received.store(0, std::memory_order_relaxed);
+    g_stream_active.store(true, std::memory_order_relaxed);
+    g_stream_complete.store(false, std::memory_order_relaxed);
+    g_stream_title_id.store(0, std::memory_order_relaxed);
+
     inst::util::initInstallServices();
+    StreamTrace("Start initInstallServices done");
     return true;
 }
 
 bool WriteStreamInstall(const void* buf, size_t size, std::uint64_t offset)
 {
+    const u64 call_idx = g_stream_write_calls.fetch_add(1, std::memory_order_relaxed) + 1;
+    const u64 t0 = armGetSystemTick();
+    bool ok = false;
+    bool has_stream = false;
     std::lock_guard<std::mutex> lock(g_stream_mutex);
-    if (!g_stream) return false;
-    return g_stream->Feed(buf, size, offset);
+    if (!g_stream) {
+        const u64 dt_ms = TicksToMs(armGetSystemTick() - t0);
+        StreamTrace("Write call=%llu no-stream off=%llu size=%zu dt_ms=%llu",
+            static_cast<unsigned long long>(call_idx),
+            static_cast<unsigned long long>(offset),
+            size,
+            static_cast<unsigned long long>(dt_ms));
+        return false;
+    }
+    has_stream = true;
+    ok = g_stream->Feed(buf, size, offset);
+    (void)has_stream;
+    const u64 dt_ms = TicksToMs(armGetSystemTick() - t0);
+    if (!ok || dt_ms >= 200 || call_idx <= 16 || (call_idx % 256ULL) == 0ULL) {
+        StreamTrace("Write call=%llu off=%llu size=%zu ok=%d dt_ms=%llu recv=%llu total=%llu",
+            static_cast<unsigned long long>(call_idx),
+            static_cast<unsigned long long>(offset),
+            size,
+            ok ? 1 : 0,
+            static_cast<unsigned long long>(dt_ms),
+            static_cast<unsigned long long>(g_stream_received.load(std::memory_order_relaxed)),
+            static_cast<unsigned long long>(g_stream_total.load(std::memory_order_relaxed)));
+    }
+    return ok;
 }
 
 void CloseStreamInstall()
 {
+    StreamTrace("Close begin");
     std::unique_ptr<StreamInstaller> stream;
     {
         std::lock_guard<std::mutex> lock(g_stream_mutex);
@@ -864,15 +1101,19 @@ void CloseStreamInstall()
     }
 
     bool ok = false;
+    const u64 t0 = armGetSystemTick();
     try {
         ok = stream->Finalize();
     } catch (const std::exception& e) {
         LOG_DEBUG("MTP close: finalize threw: %s\n", e.what());
+        StreamTrace("Close finalize exception='%s'", e.what());
         ok = false;
     } catch (...) {
         LOG_DEBUG("MTP close: finalize threw unknown exception\n");
+        StreamTrace("Close finalize unknown exception");
         ok = false;
     }
+    const u64 dt_ms = TicksToMs(armGetSystemTick() - t0);
 
     {
         std::lock_guard<std::mutex> lock(g_stream_mutex);
@@ -881,10 +1122,12 @@ void CloseStreamInstall()
     g_stream_active.store(false, std::memory_order_relaxed);
     g_stream_complete.store(ok, std::memory_order_relaxed);
     inst::util::deinitInstallServices();
+    StreamTrace("Close end ok=%d dt_ms=%llu", ok ? 1 : 0, static_cast<unsigned long long>(dt_ms));
 }
 
 void CancelStreamInstall()
 {
+    StreamTrace("Cancel begin");
     {
         std::lock_guard<std::mutex> lock(g_stream_mutex);
         g_stream.reset();
@@ -897,6 +1140,7 @@ void CancelStreamInstall()
     g_stream_received.store(0, std::memory_order_relaxed);
     g_stream_title_id.store(0, std::memory_order_relaxed);
     inst::util::deinitInstallServices();
+    StreamTrace("Cancel end");
 }
 
 bool IsStreamInstallActive()
diff --git a/source/mtp_server.cpp b/source/mtp_server.cpp
index 7cfc540..92a743b 100644
--- a/source/mtp_server.cpp
+++ b/source/mtp_server.cpp
@@ -1,6 +1,8 @@
 #include "../include/mtp_server.hpp"
 
 #include <algorithm>
+#include <atomic>
+#include <cstdarg>
 #include <cstring>
 #include <mutex>
 #include <memory>
@@ -18,6 +20,44 @@
 namespace inst::mtp {
 namespace {
 
+constexpr const char* kAlbumTracePath = "sdmc:/switch/CyberFoil/mtp_album_debug.log";
+std::mutex g_album_trace_mutex;
+std::atomic<u64> g_album_trace_count{0};
+constexpr u64 kAlbumTraceMaxLines = 20000;
+
+void AlbumTrace(const char* fmt, ...) {
+    const u64 idx = g_album_trace_count.fetch_add(1, std::memory_order_relaxed);
+    if (idx >= kAlbumTraceMaxLines) {
+        return;
+    }
+
+    char msg[512] = {};
+    va_list args;
+    va_start(args, fmt);
+    std::vsnprintf(msg, sizeof(msg), fmt, args);
+    va_end(args);
+
+    std::lock_guard<std::mutex> lock(g_album_trace_mutex);
+    FILE* f = std::fopen(kAlbumTracePath, "ab");
+    if (!f) {
+        return;
+    }
+    std::fprintf(f, "%llu %s\n", static_cast<unsigned long long>(idx), msg);
+    std::fclose(f);
+}
+
+bool CopyFsEntryName(char* dst, size_t dst_size, const char* src) {
+    if (!dst || !src || dst_size == 0) {
+        return false;
+    }
+    const size_t len = std::strlen(src);
+    if (len >= dst_size) {
+        return false;
+    }
+    std::memcpy(dst, src, len + 1);
+    return true;
+}
+
 struct InstallSharedData {
     std::mutex mutex;
     bool enabled = false;
@@ -96,7 +136,9 @@ struct FsProxyVfs : haze::FileSystemProxyImpl {
         }
 
         FsDirectoryEntry entry{};
-        std::strcpy(entry.name, file_name);
+        if (!CopyFsEntryName(entry.name, sizeof(entry.name), file_name)) {
+            return MAKERESULT(Module_Libnx, LibnxError_BadInput);
+        }
         entry.type = FsDirEntryType_File;
         entry.file_size = size;
         m_entries.emplace_back(entry);
@@ -129,7 +171,9 @@ struct FsProxyVfs : haze::FileSystemProxyImpl {
             [new_name](const auto& e){ return !strcasecmp(new_name, e.name); });
         if (new_it != m_entries.end()) return KERNELRESULT(AlreadyExists);
 
-        std::strcpy(it->name, new_name);
+        if (!CopyFsEntryName(it->name, sizeof(it->name), new_name)) {
+            return MAKERESULT(Module_Libnx, LibnxError_BadInput);
+        }
         return 0;
     }
 
@@ -326,7 +370,7 @@ struct FsInstallProxy final : FsProxyVfs {
 
     bool MultiThreadTransfer(s64 /*size*/, bool read) override {
         (void)read;
-        // Allow libhaze's multithreaded transfer path for better upload throughput.
+        // Prefer throughput for install stream; write ordering is preserved by libhaze.
         return true;
     }
 };
@@ -334,10 +378,15 @@ struct FsInstallProxy final : FsProxyVfs {
 struct FsAlbumProxy final : haze::FileSystemProxyImpl {
     FsAlbumProxy() = default;
     ~FsAlbumProxy() {
+        std::lock_guard<std::mutex> lock(m_mutex);
         if (m_fs_open) {
             fsFsClose(&m_fs);
             m_fs_open = false;
         }
+        if (m_sd_fs_open) {
+            fsFsClose(&m_sd_fs);
+            m_sd_fs_open = false;
+        }
     }
 
     const char* GetName() const override {
@@ -348,6 +397,10 @@ struct FsAlbumProxy final : haze::FileSystemProxyImpl {
         return "Album (Screenshots & Videos)";
     }
 
+    u16 GetAccessCapability() const override {
+        return static_cast<u16>(haze::PtpAccessCapability_ReadOnly);
+    }
+
     Result GetTotalSpace(const char* /*path*/, s64* out) override {
         return QuerySdSpace(out, nullptr);
     }
@@ -358,76 +411,194 @@ struct FsAlbumProxy final : haze::FileSystemProxyImpl {
 
     Result GetEntryType(const char* path, FsDirEntryType* out_entry_type) override {
         if (!out_entry_type) return MAKERESULT(Module_Libnx, LibnxError_BadInput);
-        const Result rc = EnsureFsOpen();
+        std::lock_guard<std::mutex> lock(m_mutex);
+        const Result rc = EnsureFsOpenLocked();
         if (R_FAILED(rc)) return rc;
         const auto fixed = FixPath(path);
         if (fixed.empty()) return MAKERESULT(Module_Libnx, LibnxError_BadInput);
-        return fsFsGetEntryType(&m_fs, fixed.c_str(), out_entry_type);
+        Result out_rc = 0;
+        for (int attempt = 0; attempt < 10; ++attempt) {
+            out_rc = fsFsGetEntryType(&m_fs, fixed.c_str(), out_entry_type);
+            if (R_SUCCEEDED(out_rc)) {
+                break;
+            }
+            // The album backend can return occasional transient lookup failures under
+            // host-side parallel metadata probing; retry a couple of times.
+            svcSleepThread(10'000'000);
+        }
+        if (R_FAILED(out_rc)) {
+            FsDir dir{};
+            const Result dir_rc = fsFsOpenDirectory(&m_fs, fixed.c_str(), FsDirOpenMode_ReadDirs, &dir);
+            if (R_SUCCEEDED(dir_rc)) {
+                fsDirClose(&dir);
+                *out_entry_type = FsDirEntryType_Dir;
+                AlbumTrace("GetEntryType fallback-dir path='%s' fixed='%s' rc=0x%08x",
+                    path ? path : "(null)", fixed.c_str(), out_rc);
+                return 0;
+            }
+
+            FsFile file{};
+            const Result file_rc = fsFsOpenFile(&m_fs, fixed.c_str(), FsOpenMode_Read, &file);
+            if (R_SUCCEEDED(file_rc)) {
+                fsFileClose(&file);
+                *out_entry_type = FsDirEntryType_File;
+                AlbumTrace("GetEntryType fallback-file path='%s' fixed='%s' rc=0x%08x",
+                    path ? path : "(null)", fixed.c_str(), out_rc);
+                return 0;
+            }
+
+            const auto slash = fixed.find_last_of('/');
+            const auto dot = fixed.find_last_of('.');
+            const bool looks_like_file = (dot != std::string::npos) &&
+                                         (slash == std::string::npos || dot > slash + 1);
+            *out_entry_type = looks_like_file ? FsDirEntryType_File : FsDirEntryType_Dir;
+            AlbumTrace("GetEntryType fallback-heuristic path='%s' fixed='%s' rc=0x%08x inferred=%d",
+                path ? path : "(null)", fixed.c_str(), out_rc, static_cast<int>(*out_entry_type));
+            return 0;
+        }
+        AlbumTrace("GetEntryType path='%s' fixed='%s' rc=0x%08x type=%d",
+            path ? path : "(null)", fixed.c_str(), out_rc, R_SUCCEEDED(out_rc) ? static_cast<int>(*out_entry_type) : -1);
+        return out_rc;
     }
 
-    Result CreateFile(const char* /*path*/, s64 /*size*/, u32 /*option*/) override { return KERNELRESULT(NotImplemented); }
-    Result DeleteFile(const char* /*path*/) override { return KERNELRESULT(NotImplemented); }
-    Result RenameFile(const char* /*old_path*/, const char* /*new_path*/) override { return KERNELRESULT(NotImplemented); }
-    Result SetFileSize(FsFile* /*file*/, s64 /*size*/) override { return KERNELRESULT(NotImplemented); }
-    Result WriteFile(FsFile* /*file*/, s64 /*off*/, const void* /*buf*/, u64 /*write_size*/, u32 /*option*/) override { return KERNELRESULT(NotImplemented); }
-    Result CreateDirectory(const char* /*path*/) override { return KERNELRESULT(NotImplemented); }
-    Result DeleteDirectoryRecursively(const char* /*path*/) override { return KERNELRESULT(NotImplemented); }
-    Result RenameDirectory(const char* /*old_path*/, const char* /*new_path*/) override { return KERNELRESULT(NotImplemented); }
+    Result CreateFile(const char* /*path*/, s64 /*size*/, u32 /*option*/) override { return static_cast<Result>(haze::ResultOperationNotSupported::Value); }
+    Result DeleteFile(const char* /*path*/) override { return static_cast<Result>(haze::ResultOperationNotSupported::Value); }
+    Result RenameFile(const char* /*old_path*/, const char* /*new_path*/) override { return static_cast<Result>(haze::ResultOperationNotSupported::Value); }
+    Result SetFileSize(FsFile* /*file*/, s64 /*size*/) override { return static_cast<Result>(haze::ResultOperationNotSupported::Value); }
+    Result WriteFile(FsFile* /*file*/, s64 /*off*/, const void* /*buf*/, u64 /*write_size*/, u32 /*option*/) override { return static_cast<Result>(haze::ResultOperationNotSupported::Value); }
+    Result CreateDirectory(const char* /*path*/) override { return static_cast<Result>(haze::ResultOperationNotSupported::Value); }
+    Result DeleteDirectoryRecursively(const char* /*path*/) override { return static_cast<Result>(haze::ResultOperationNotSupported::Value); }
+    Result RenameDirectory(const char* /*old_path*/, const char* /*new_path*/) override { return static_cast<Result>(haze::ResultOperationNotSupported::Value); }
 
     Result OpenFile(const char* path, u32 mode, FsFile* out_file) override {
         if (!out_file) return MAKERESULT(Module_Libnx, LibnxError_BadInput);
-        if ((mode & FsOpenMode_Write) || (mode & FsOpenMode_Append)) return KERNELRESULT(NotImplemented);
-        const Result rc = EnsureFsOpen();
+        if ((mode & FsOpenMode_Write) || (mode & FsOpenMode_Append)) return static_cast<Result>(haze::ResultOperationNotSupported::Value);
+        std::memset(out_file, 0, sizeof(*out_file));
+        std::lock_guard<std::mutex> lock(m_mutex);
+        const Result rc = EnsureFsOpenLocked();
         if (R_FAILED(rc)) return rc;
         const auto fixed = FixPath(path);
         if (fixed.empty()) return MAKERESULT(Module_Libnx, LibnxError_BadInput);
-        return fsFsOpenFile(&m_fs, fixed.c_str(), FsOpenMode_Read, out_file);
+        Result out_rc = 0;
+        for (int attempt = 0; attempt < 8; ++attempt) {
+            out_rc = fsFsOpenFile(&m_fs, fixed.c_str(), FsOpenMode_Read, out_file);
+            if (R_SUCCEEDED(out_rc)) {
+                break;
+            }
+
+            // Try to recover from transient album backend faults by reopening once.
+            if (out_rc == 0x0000d401 && attempt == 3) {
+                fsFsClose(&m_fs);
+                m_fs_open = false;
+                const Result reopen_rc = EnsureFsOpenLocked();
+                AlbumTrace("OpenFile reopen attempt rc=0x%08x", reopen_rc);
+                if (R_FAILED(reopen_rc)) {
+                    break;
+                }
+            }
+            svcSleepThread(10'000'000);
+        }
+        if (R_FAILED(out_rc)) {
+            Result sd_rc = 0;
+            const std::string sd_path = ToSdAlbumPath(fixed);
+            if (!sd_path.empty()) {
+                sd_rc = OpenFileFromSdLocked(sd_path.c_str(), out_file);
+                if (R_SUCCEEDED(sd_rc)) {
+                    AlbumTrace("OpenFile fallback-sd path='%s' fixed='%s' sd='%s' rc=0x%08x",
+                        path ? path : "(null)", fixed.c_str(), sd_path.c_str(), sd_rc);
+                    return sd_rc;
+                }
+            } else {
+                sd_rc = MAKERESULT(Module_Libnx, LibnxError_BadInput);
+            }
+            AlbumTrace("OpenFile fallback-sd-failed path='%s' fixed='%s' sd='%s' rc=0x%08x",
+                path ? path : "(null)", fixed.c_str(), sd_path.empty() ? "(invalid)" : sd_path.c_str(), sd_rc);
+        }
+        AlbumTrace("OpenFile path='%s' fixed='%s' mode=0x%x rc=0x%08x",
+            path ? path : "(null)", fixed.c_str(), mode, out_rc);
+        return out_rc;
     }
 
     Result GetFileSize(FsFile* file, s64* out_size) override {
         if (!file || !out_size) return MAKERESULT(Module_Libnx, LibnxError_BadInput);
-        return fsFileGetSize(file, out_size);
+        Result rc = 0;
+        for (int attempt = 0; attempt < 8; ++attempt) {
+            rc = fsFileGetSize(file, out_size);
+            if (R_SUCCEEDED(rc)) {
+                break;
+            }
+            svcSleepThread(5'000'000);
+        }
+        AlbumTrace("GetFileSize rc=0x%08x size=%lld",
+            rc, static_cast<long long>(R_SUCCEEDED(rc) ? *out_size : -1));
+        return rc;
     }
 
     Result ReadFile(FsFile* file, s64 off, void* buf, u64 read_size, u32 /*option*/, u64* out_bytes_read) override {
         if (!file || !buf || !out_bytes_read) return MAKERESULT(Module_Libnx, LibnxError_BadInput);
-        return fsFileRead(file, off, buf, read_size, FsReadOption_None, out_bytes_read);
+        const Result rc = fsFileRead(file, off, buf, read_size, FsReadOption_None, out_bytes_read);
+        AlbumTrace("ReadFile off=%lld req=%llu rc=0x%08x got=%llu",
+            static_cast<long long>(off),
+            static_cast<unsigned long long>(read_size),
+            rc,
+            static_cast<unsigned long long>(R_SUCCEEDED(rc) ? *out_bytes_read : 0));
+        return rc;
     }
 
     void CloseFile(FsFile* file) override {
         if (file) {
             fsFileClose(file);
+            AlbumTrace("CloseFile");
         }
     }
 
     Result OpenDirectory(const char* path, u32 /*mode*/, FsDir* out_dir) override {
         if (!out_dir) return MAKERESULT(Module_Libnx, LibnxError_BadInput);
-        const Result rc = EnsureFsOpen();
+        std::lock_guard<std::mutex> lock(m_mutex);
+        const Result rc = EnsureFsOpenLocked();
         if (R_FAILED(rc)) return rc;
         const auto fixed = FixPath(path);
         if (fixed.empty()) return MAKERESULT(Module_Libnx, LibnxError_BadInput);
-        return fsFsOpenDirectory(&m_fs, fixed.c_str(),
-            FsDirOpenMode_ReadDirs | FsDirOpenMode_ReadFiles | FsDirOpenMode_NoFileSize, out_dir);
+        const Result out_rc = fsFsOpenDirectory(&m_fs, fixed.c_str(),
+            FsDirOpenMode_ReadDirs | FsDirOpenMode_ReadFiles, out_dir);
+        AlbumTrace("OpenDirectory path='%s' fixed='%s' rc=0x%08x",
+            path ? path : "(null)", fixed.c_str(), out_rc);
+        return out_rc;
     }
 
     Result ReadDirectory(FsDir* d, s64* out_total_entries, size_t max_entries, FsDirectoryEntry* buf) override {
         if (!d || !out_total_entries || !buf) return MAKERESULT(Module_Libnx, LibnxError_BadInput);
-        return fsDirRead(d, out_total_entries, max_entries, buf);
+        const Result rc = fsDirRead(d, out_total_entries, max_entries, buf);
+        AlbumTrace("ReadDirectory max=%llu rc=0x%08x read=%lld",
+            static_cast<unsigned long long>(max_entries), rc,
+            static_cast<long long>(R_SUCCEEDED(rc) ? *out_total_entries : -1));
+        return rc;
     }
 
     Result GetDirectoryEntryCount(FsDir* d, s64* out_count) override {
         if (!d || !out_count) return MAKERESULT(Module_Libnx, LibnxError_BadInput);
-        return fsDirGetEntryCount(d, out_count);
+        const Result rc = fsDirGetEntryCount(d, out_count);
+        AlbumTrace("GetDirectoryEntryCount rc=0x%08x count=%lld",
+            rc, static_cast<long long>(R_SUCCEEDED(rc) ? *out_count : -1));
+        return rc;
     }
 
     void CloseDirectory(FsDir* d) override {
         if (d) {
             fsDirClose(d);
+            AlbumTrace("CloseDirectory");
         }
     }
 
+    bool MultiThreadTransfer(s64 /*size*/, bool read) override {
+        /* Album reads are more reliable on this backend with conservative transfer mode. */
+        const bool allow = !read;
+        AlbumTrace("MultiThreadTransfer read=%d allow=%d", read ? 1 : 0, allow ? 1 : 0);
+        return allow;
+    }
+
 private:
-    Result EnsureFsOpen() {
+    Result EnsureFsOpenLocked() {
         if (!m_fs_open) {
             const Result rc = fsOpenImageDirectoryFileSystem(&m_fs, FsImageDirectoryId_Sd);
             if (R_FAILED(rc)) return rc;
@@ -436,6 +607,41 @@ private:
         return 0;
     }
 
+    Result EnsureSdFsOpenLocked() {
+        if (!m_sd_fs_open) {
+            const Result rc = fsOpenSdCardFileSystem(&m_sd_fs);
+            if (R_FAILED(rc)) return rc;
+            m_sd_fs_open = true;
+        }
+        return 0;
+    }
+
+    Result OpenFileFromSdLocked(const char* sd_path, FsFile* out_file) {
+        if (!sd_path || !out_file) return MAKERESULT(Module_Libnx, LibnxError_BadInput);
+        Result rc = EnsureSdFsOpenLocked();
+        if (R_FAILED(rc)) {
+            return rc;
+        }
+        for (int attempt = 0; attempt < 4; ++attempt) {
+            rc = fsFsOpenFile(&m_sd_fs, sd_path, FsOpenMode_Read, out_file);
+            if (R_SUCCEEDED(rc)) {
+                return rc;
+            }
+            svcSleepThread(5'000'000);
+        }
+        return rc;
+    }
+
+    static std::string ToSdAlbumPath(const std::string& fixed) {
+        if (fixed.empty() || fixed.find("..") != std::string::npos) {
+            return {};
+        }
+        if (fixed == "/") {
+            return "/Nintendo/Album";
+        }
+        return "/Nintendo/Album" + fixed;
+    }
+
     static Result QuerySdSpace(s64* out_total, s64* out_free) {
         NcmContentStorage storage{};
         Result rc = ncmOpenContentStorage(&storage, NcmStorageId_SdCard);
@@ -460,6 +666,9 @@ private:
 
     FsFileSystem m_fs{};
     bool m_fs_open = false;
+    FsFileSystem m_sd_fs{};
+    bool m_sd_fs_open = false;
+    std::mutex m_mutex;
 };
 
 haze::FsEntries g_entries;
@@ -476,13 +685,24 @@ bool StartInstallServer(int storage_choice)
     if (g_running) return true;
 
     g_storage_choice = storage_choice;
+    std::remove(kAlbumTracePath);
+    g_album_trace_count.store(0, std::memory_order_relaxed);
     if (!g_awoo_suspended) {
         awoo_usbCommsExit();
         g_awoo_suspended = true;
     }
     if (!g_ncm_ready) {
-        if (R_SUCCEEDED(ncmInitialize())) {
+        const Result rc = ncmInitialize();
+        if (R_SUCCEEDED(rc)) {
             g_ncm_ready = true;
+        } else {
+            if (g_awoo_suspended) {
+                const Result resume_rc = awoo_usbCommsInitialize();
+                if (R_SUCCEEDED(resume_rc) || resume_rc == MAKERESULT(Module_Libnx, LibnxError_AlreadyInitialized)) {
+                    g_awoo_suspended = false;
+                }
+            }
+            return false;
         }
     }
     g_entries.clear();
diff --git a/source/nx/nca_writer.cpp b/source/nx/nca_writer.cpp
index dcca04f..1ee3218 100755
--- a/source/nx/nca_writer.cpp
+++ b/source/nx/nca_writer.cpp
@@ -28,6 +28,7 @@ SOFTWARE.
 #include "util/config.hpp"
 #include "util/title_util.hpp"
 #include "install/nca.hpp"
+#include <limits>
 
 void append(std::vector<u8>& buffer, const u8* ptr, u64 sz)
 {
@@ -201,16 +202,29 @@ public:
           return true;
      }
 
-     NczHeader::SectionContext& section(u64 offset)
+     NczHeader::SectionContext* section(u64 offset)
      {
           for (u64 i = 0; i < sections.size(); i++)
           {
                if (offset >= sections[i]->offset && offset < sections[i]->offset + sections[i]->size)
                {
-                    return *sections[i];
+                    return sections[i];
                }
           }
-          return *sections[0];
+          return NULL;
+     }
+
+     u64 nextSectionOffset(u64 offset) const
+     {
+          u64 next = std::numeric_limits<u64>::max();
+          for (u64 i = 0; i < sections.size(); i++)
+          {
+               if (sections[i]->offset > offset && sections[i]->offset < next)
+               {
+                    next = sections[i]->offset;
+               }
+          }
+          return next;
      }
 
      bool encrypt(const void* ptr, u64 sz, u64 offset)
@@ -220,13 +234,31 @@ public:
 
           while (start < end)
           {
-               auto& s = section(offset);
+               auto* s = section(offset);
+               u64 chunk = sz;
 
-               u64 sectionEnd = s.offset + s.size;
-
-               u64 chunk = offset + sz > sectionEnd ? sectionEnd - offset : sz;
+               if (s)
+               {
+                    const u64 sectionEnd = s->offset + s->size;
+                    if (sectionEnd > offset)
+                    {
+                         chunk = std::min<u64>(sz, sectionEnd - offset);
+                         s->encrypt((void*)start, chunk, offset);
+                    }
+               }
+               else
+               {
+                    const u64 next = nextSectionOffset(offset);
+                    if (next != std::numeric_limits<u64>::max() && next > offset)
+                    {
+                         chunk = std::min<u64>(sz, next - offset);
+                    }
+               }
 
-               s.encrypt((void*)start, chunk, offset);
+               if (chunk == 0)
+               {
+                    return false;
+               }
 
                offset += chunk;
                start += chunk;
